# Contributing to govalid

Thank you for your interest in contributing to govalid! This document provides guidelines for contributing to the project, with a focus on implementing new validation markers.

## üöÄ Getting Started

### Prerequisites

- Go 1.24 or later
- Git
- golangci-lint for code quality checks

### Development Setup

1. Fork and clone the repository:
```bash
git clone https://github.com/yourusername/govalid.git
cd govalid
```

2. Install dependencies:
```bash
go mod download
```

3. Install the govalid binary:
```bash
go install ./cmd/govalid/
```

## üìù How to Add a New Validation Marker

### Overview

Adding a new marker involves implementing the validator logic, integrating it with the analyzer, and adding comprehensive tests. Follow this step-by-step guide:

### Step 1: Feature Branch Setup

```bash
git checkout -b feature/{marker-name}-marker
```

### Step 2: Core Implementation

#### A. Define the Marker (`internal/markers/markers.go`)

Add your marker constant:

```go
// GoValidMarker{MarkerName} is the marker for {description}.
// This marker is only available for {type} types.
GoValidMarker{MarkerName} = "govalid:{markername}"
```

#### B. Implement the Validator (`internal/validator/rules/{markername}.go`)

Create a new validator file following this pattern:

```go
package rules

import (
    "fmt"
    "go/ast"
    "strings"
    "github.com/gostaticanalysis/codegen"
    "github.com/sivchari/govalid/internal/validator"
)

type {markerName}Validator struct {
    pass           *codegen.Pass
    field          *ast.Field
    {markerName}Value string // or appropriate type (int, bool, etc.)
}

var _ validator.Validator = (*{markerName}Validator)(nil)

const {markerName}Key = "%s-{markername}"

func (v *{markerName}Validator) Validate() string {
    // Return the validation logic as Go code
    return fmt.Sprintf("{validation_logic}", v.FieldName(), v.{markerName}Value)
}

func (v *{markerName}Validator) FieldName() string {
    return v.field.Names[0].Name
}

func (v *{markerName}Validator) Err() string {
    if validator.GeneratorMemory[fmt.Sprintf({markerName}Key, v.FieldName())] {
        return ""
    }

    validator.GeneratorMemory[fmt.Sprintf({markerName}Key, v.FieldName())] = true

    return fmt.Sprintf(strings.ReplaceAll(`
    // Err@{MarkerName}Validation is the error returned when {description}.
    Err@{MarkerName}Validation = errors.New("{error message}")`, "@", v.FieldName()))
}

func (v *{markerName}Validator) ErrVariable() string {
    return strings.ReplaceAll("Err@{MarkerName}Validation", "@", v.FieldName())
}

func (v *{markerName}Validator) Imports() []string {
    // Return required imports for your validation logic
    return []string{} // e.g., []string{"unicode/utf8"} for string validators
}

// Validate{MarkerName} creates a new {markerName}Validator if conditions are met.
func Validate{MarkerName}(pass *codegen.Pass, field *ast.Field, expressions map[string]string) validator.Validator {
    // Add type checking and marker validation logic
    // Return validator instance or nil
}
```

#### C. Integrate with Analyzer (`analyzers/govalid/govalid.go`)

Add your marker to the `makeValidator` function:

```go
case markers.GoValidMarker{MarkerName}:
    v = rules.Validate{MarkerName}(pass, field, marker.Expressions)
```

### Step 3: Testing Implementation

#### A. Golden Tests (`analyzers/govalid/testdata/src/{markername}/`)

Create test input file `{markername}.go`:

```go
package {markername}

//govalid:generate
type {MarkerName} struct {
    Field string `govalid:"{markername}=value"`
}
```

Create expected output file `govalid.golden`:

```go
// Code generated by govalid. DO NOT EDIT.

package {markername}

import "fmt"

func Validate{MarkerName}(t *{MarkerName}) error {
    // Expected generated validation code
    return nil
}
```

#### B. Unit Tests (`test/unit/{markername}_test.go`)

```go
package unit

import (
    "testing"
    "github.com/sivchari/govalid/test"
)

func Test{MarkerName}Validation(t *testing.T) {
    tests := []struct {
        name        string
        data        test.{MarkerName}
        expectError bool
    }{
        {"valid_case", test.{MarkerName}{Field: "valid_value"}, false},
        {"boundary_minus_one", test.{MarkerName}{Field: "boundary-1"}, false},
        {"exactly_at_boundary", test.{MarkerName}{Field: "boundary"}, false},
        {"boundary_plus_one", test.{MarkerName}{Field: "boundary+1"}, true},
        {"invalid_case", test.{MarkerName}{Field: "invalid_value"}, true},
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            err := test.Validate{MarkerName}(&tt.data)
            hasError := err != nil
            
            if hasError != tt.expectError {
                t.Errorf("expected error: %v, got error: %v (%v)", tt.expectError, hasError, err)
            }
        })
    }
}
```

#### C. Benchmark Tests (`test/benchmark/benchmark_{markername}_test.go`)

```go
package benchmark

import (
    "testing"
    "github.com/go-playground/validator/v10"
    "github.com/sivchari/govalid/test"
)

func BenchmarkGoValid{MarkerName}(b *testing.B) {
    instance := test.{MarkerName}{Field: "test_value"}
    b.ResetTimer()
    for b.Loop() {
        err := test.Validate{MarkerName}(&instance)
        if err != nil {
            b.Fatal("unexpected error:", err)
        }
    }
    b.StopTimer()
}

func BenchmarkGoPlayground{MarkerName}(b *testing.B) {
    validate := validator.New()
    instance := test.{MarkerName}{Field: "test_value"}
    b.ResetTimer()
    for b.Loop() {
        err := validate.Struct(&instance)
        if err != nil {
            b.Fatal("unexpected error:", err)
        }
    }
    b.StopTimer()
}
```

### Step 4: Test Execution and Validation

Run tests in this specific order:

```bash
# 1. Build and install updated binary
go install ./cmd/govalid/

# 2. Generate test files
cd test && go generate

# 3. Run golden tests
cd .. && go test ./analyzers/govalid/ -v

# 4. Run unit tests
cd test && go test ./unit/ -v

# 5. Run benchmarks
go test ./benchmark/ -bench=Benchmark.*{MarkerName} -benchmem

# 6. Run lint checks
cd .. && make golangci-lint

# 7. Fix any lint issues and re-run benchmarks if needed
```

### Step 5: Documentation Updates

1. Update `MARKERS.md` with your marker documentation
2. Update `docs/content/validators.md` with usage examples and behavior details

## ü§ù Getting Help

- **Issues**: Check existing issues or create a new one
- **Discussions**: Use GitHub Discussions for questions
- **Code patterns**: Reference existing markers (MaxLength, GT, etc.) as examples

## üìú License

By contributing to govalid, you agree that your contributions will be licensed under the same license as the project.